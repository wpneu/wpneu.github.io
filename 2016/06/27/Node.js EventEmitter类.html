<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="郑超的个人博客，Charles·Zheng's blog."><meta name="keywords" content="技术博客, 前端, JavaScript, Charles"><title>Node.js EventEmitter类(3) | 秋过冬漫长</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Node.js EventEmitter类(3)</h1><a id="logo" href="/.">秋过冬漫长</a><p class="description">没有比脚更长的路，走过去，前面是个天！</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Node.js EventEmitter类(3)</h1><div class="post-meta"><a href="/2016/06/27/Node.js EventEmitter类.html#comments" class="comment-count"></a><p><span class="date">Jun 27, 2016</span><span><a href="/categories/nodeJS学习笔记/" class="category">nodeJS学习笔记</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="3、Node-js-EventEmitter-类"><a href="#3、Node-js-EventEmitter-类" class="headerlink" title="3、Node.js EventEmitter 类"></a>3、Node.js EventEmitter 类</h3><p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。<br>Node.js里面的许多对象都会分发事件：一个<code>net.Server</code> 对象会在每次有新连接时分发一个事件， 一个<code>fs.readStream</code>对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 <code>events.EventEmitter</code> 的实例。<br><code>events</code> 模块只提供了一个对象： <code>events.EventEmitter</code>。<code>EventEmitter</code> 的核心就是事件触发与事件监听器功能的封装。<br>你可以通过<code>require(&quot;events&quot;)</code>;来访问该模块:<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="comment">//创建eventEmitter对象</span></div><div class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</div></pre></td></tr></table></figure></p>
<p><code>EventEmitter</code> 对象如果在实例化时发生错误，会触发 <code>&#39;error&#39;</code> 事件。当添加新的监听器时，<code>&#39;newListener&#39;</code> 事件会触发，当监听器被移除时，<code>&#39;removeListener&#39;</code> 事件被触发。实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//event.js 文件</span></div><div class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</div><div class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> EventEmitter();</div><div class="line">event.on(<span class="string">'some_event'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'some_event事件触发'</span>)；</div><div class="line">&#125;);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  event.emit(<span class="string">'some_event'</span>);</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure></p>
<p>运行这段代码，1 秒后控制台输出了 <code>some_event 事件触发</code>。其原理是 <code>event</code> 对象注册了事件 <code>some_event</code> 的一个监听器，然后我们通过 <code>setTimeout</code> 在 1000 毫秒以后向 <code>event</code> 对象发送事件 <code>some_event</code>，此时会调用<code>some_event</code> 的监听器<br>执行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">node event.js </div><div class="line">some_event 事件触发</div></pre></td></tr></table></figure></p>
<p><code>EventEmitter</code> 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，<code>EventEmitter</code> 支持 若干个事件监听器。当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//event.js 文件</span></div><div class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.EventEmitter(); </div><div class="line">emitter.on(<span class="string">'someEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; </div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'listener1'</span>, arg1, arg2); </div><div class="line">&#125;); </div><div class="line">emitter.on(<span class="string">'someEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; </div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'listener2'</span>, arg1, arg2); </div><div class="line">&#125;); </div><div class="line">emitter.emit(<span class="string">'someEvent'</span>, <span class="string">'arg1 参数'</span>, <span class="string">'arg2 参数'</span>);</div></pre></td></tr></table></figure></p>
<p><code>emitter</code> 为事件 <code>someEvent</code> 注册了两个事件监听器，然后触发了 <code>someEvent</code> 事件。运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是<code>EventEmitter</code>最简单的用法。<code>EventEmitter</code> 提供了多个属性，如 <code>on</code> 和 <code>emit</code>。<code>on</code> 函数用于绑定事件函数，<code>emit</code> 属性用于触发一个事件。<br>执行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">node event.js </div><div class="line">listener1 arg1 参数 arg2 参数</div><div class="line">listener2 arg1 参数 arg2 参数</div></pre></td></tr></table></figure></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>1、<code>addListener(event, listener)</code>//为指定事件添加一个监听器到监听数组的尾部<br>2、<code>on(event, listener)</code>//为指定事件注册一个监听器，接受一个字符串 <code>event</code> 和一个回调函数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">server.on(<span class="string">'connection'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'someone connected!'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>3、<code>once(event, listener)</code>//为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">server.once(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Ah, we have our first user!'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>4、<code>removeListener(event, listener)</code>//移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">stream</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'someone connected!'</span>);</div><div class="line">&#125;;</div><div class="line">server.on(<span class="string">'connection'</span>, callback);</div><div class="line"><span class="comment">// ...</span></div><div class="line">server.removeListener(<span class="string">'connection'</span>, callback);</div></pre></td></tr></table></figure></p>
<p>5、<code>removeAllListeners([event])</code>//移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。<br>6、<code>setMaxListeners(n)</code>//默认情况下， <code>EventEmitters</code> 如果你添加的监听器超过 10 个就会输出警告信息。 <code>setMaxListeners</code> 函数用于提高监听器的默认限制的数量。<br>7、<code>listeners(event)</code>//返回指定事件的监听器数组<br>8、<code>emit(event, [arg1], [arg2], [...])</code>//按参数的顺序执行每个监听器，如果事件有注册监听返回 <code>true</code>，否则返回 <code>false</code>。</p>
<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>1、<code>listenerCount(emitter, event)</code>//返回指定事件的监听器数量。</p>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>1、<code>newListener</code> //该事件再添加新监听器时被触发<br>  <code>event</code> - 字符串，事件名称<br>  <code>listener</code> - 处理事件函数<br>2、<code>removeListener</code>//从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。<br>  <code>event</code> - 字符串，事件名称<br>  <code>listener</code> - 处理事件函数<br>实例：通过 <code>connection</code>（连接）事件演示了 <code>EventEmitter</code> 类的应用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建main.js文件：</span></div><div class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</div><div class="line"><span class="comment">// 监听器 #1</span></div><div class="line"><span class="keyword">var</span> listener1 = <span class="function"><span class="keyword">function</span> <span class="title">listener1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'监听器 listener1 执行。'</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 监听器 #2</span></div><div class="line"><span class="keyword">var</span> listener2 = <span class="function"><span class="keyword">function</span> <span class="title">listener2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'监听器 listener2 执行。'</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 绑定connection事件，处理函数为listener1</span></div><div class="line">eventEmitter.addListener(<span class="string">'connection'</span>,listener1);</div><div class="line"><span class="comment">// 绑定connection事件，处理函数为listener2</span></div><div class="line">eventEmitter.on(<span class="string">'connection'</span>,listener2);</div><div class="line"><span class="keyword">var</span> eventListeners = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter.listenerCount(eventEmitter,<span class="string">'connection'</span>);</div><div class="line"><span class="built_in">console</span>.log(eventListeners + <span class="string">"个监听器连接事件"</span>);</div><div class="line"><span class="comment">//处理connection事件</span></div><div class="line">eventEmitter.emit(<span class="string">'connection'</span>);</div><div class="line"><span class="comment">//移除监绑定的listener1函数</span></div><div class="line">eventEmitter.removeListener(<span class="string">'connection'</span>,listener1);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"listener1不再受监听。"</span>);</div><div class="line"><span class="comment">//触发连接事件</span></div><div class="line">eventEmitter.emit(<span class="string">'connection'</span>);</div><div class="line">eventListeners = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter.listenerCount(eventEmitter,<span class="string">'connection'</span>);</div><div class="line"><span class="built_in">console</span>.log(eventListeners + <span class="string">"个监听器连接事件"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕。"</span>);</div></pre></td></tr></table></figure></p>
<p>//执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">node main.js</div><div class="line">2个监听器连接事件</div><div class="line">监听器 listener1 执行。</div><div class="line">监听器 listener2 执行。</div><div class="line">listener1不再受监听。</div><div class="line">监听器 listener2 执行。</div><div class="line">1个监听器连接事件</div><div class="line">程序执行完毕。</div></pre></td></tr></table></figure></p>
<h4 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h4><p><code>EventEmitter</code> 定义了一个特殊的事件 <code>error</code>，它包含了错误的语义，我们在遇到 异常的时候通常会触发 <code>error</code> 事件。当 <code>error</code> 被触发时，<code>EventEmitter</code> 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。我们一般要为会触发 <code>error</code> 事件的对象设置监听器，避免遇到错误后整个程序崩溃。</p>
<h4 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h4><p>大多数时候我们不会直接使用 <code>EventEmitter</code>，而是在对象中继承它。包括 <code>fs、net、 http</code> 在内的，只要是支持事件响应的核心模块都是 <code>EventEmitter</code>的子类。<br>原因有两点：<br>  -首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。<br>  -其次 <code>JavaScript</code> 的对象机制是基于原型的，支持 部分多重继承，继承 <code>EventEmitter</code> 不会打乱对象原有的继承关系。</p>
</div><div class="tags"><a href="/tags/node/">node</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2016/06/27/Node.js Buffer.html" class="pre">Node.js Buffer缓冲区(4)</a><a href="/2016/06/27/Node.js 事件循环.html" class="next">NodeJs学习笔记(2)</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#3、Node-js-EventEmitter-类"><span class="toc-text">3、Node.js EventEmitter 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类方法"><span class="toc-text">类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件"><span class="toc-text">事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#error事件"><span class="toc-text">error事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继承-EventEmitter"><span class="toc-text">继承 EventEmitter</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/12/29/BlueLake博客主题的详细配置.html">BlueLake博客主题的详细配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/09/自定义HEXO站内搜索Javascript-json.html">自定义HEXO站内搜索Javascript+json</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/17/github博客迁移.html">github博客迁移</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/12/Web包管理器-Bower.html">好用的Web包管理器-Bower</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/30/MongoDB学习笔记(2).html">MongoDB学习笔记(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/29/MongoDB学习笔记(1).html">MongoDB学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/30/Node.js 多进程.html">Node.js 多进程(17)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/30/Node.js RESTful API.html">Node.js RESTful API(16)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/30/Node.js Express 框架.html">Node.js Express 框架(15)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/Node.js Web模块.html">Node.js Web 模块(14)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/hexo博客折腾/">hexo博客折腾</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodeJS学习笔记/">nodeJS学习笔记</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端工具/">前端工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言集成查询/">语言集成查询</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/linq/" style="font-size: 15px;">linq</a> <a href="/tags/语言集成查询/" style="font-size: 15px;">语言集成查询</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/BlueLake/" style="font-size: 15px;">BlueLake</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/bower/" style="font-size: 15px;">bower</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/sublime/" style="font-size: 15px;">sublime</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">郑超(Charles·Zheng).</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>