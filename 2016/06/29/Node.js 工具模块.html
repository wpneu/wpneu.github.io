<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="王志平，终身学习者，Gavin.Wang's blog."><meta name="keywords" content="技术博客, Embeded Linux, linux驱动, linux内核"><title>Node.js 工具模块(13) | 老王的程序人生</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Node.js 工具模块(13)</h1><a id="logo" href="/.">老王的程序人生</a><p class="description">没有比脚更长的路，走过去，前面是个天！</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Node.js 工具模块(13)</h1><div class="post-meta"><a href="/2016/06/29/Node.js 工具模块.html#comments" class="comment-count"><i data-thread-key="2016/06/29/Node.js 工具模块.html" class="ds-thread-count"></i>留言<a id="uyan_count_unit" href="/2016/06/29/Node.js 工具模块.html"></a>留言</a><p><span class="date">Jun 29, 2016</span><span><a href="/categories/nodeJS学习笔记/" class="category">nodeJS学习笔记</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="13、Node-js-工具模块"><a href="#13、Node-js-工具模块" class="headerlink" title="13、Node.js 工具模块"></a>13、Node.js 工具模块</h3><h4 id="Node-js-OS-模块"><a href="#Node-js-OS-模块" class="headerlink" title="Node.js OS 模块"></a>Node.js OS 模块</h4><p>Node.js os 模块提供了一些基本的系统操作函数。我们可以通过以下方式引入该模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> os = <span class="built_in">require</span>(<span class="string">"os"</span>);</div></pre></td></tr></table></figure></p>
<h5 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h5><p>1  <code>os.tmpdir()</code>//返回操作系统的默认临时文件夹。<br><a id="more"></a><br>2  <code>os.endianness()</code>//返回 CPU 的字节序，可能的是 “BE” 或 “LE”。<br>3  <code>os.hostname()</code>//返回操作系统的主机名。<br>4  <code>os.type()</code>//返回操作系统名<br>5  <code>os.platform()</code>//返回操作系统名<br>6  <code>os.arch()</code>//返回操作系统 CPU 架构，可能的值有 “x64”、”arm” 和 “ia32”。<br>7  <code>os.release()</code>//返回操作系统的发行版本。<br>8  <code>os.uptime()</code>//返回操作系统运行的时间，以秒为单位。<br>9  <code>os.loadavg()</code>//返回一个包含 1、5、15 分钟平均负载的数组。<br>10  <code>os.totalmem()</code>//返回系统内存总量，单位为字节。<br>11  <code>os.freemem()</code>//返回操作系统空闲内存量，单位是字节。<br>12  <code>os.cpus()</code>//返回一个对象数组，包含所安装的每个 CPU/内核的信息：型号、速度（单位 MHz）、时间（一个包含 user、nice、sys、idle 和 irq 所使用 CPU/内核毫秒数的对象）。<br>13  <code>os.networkInterfaces()</code>//获得网络接口列表。</p>
<h5 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h5><p><code>os.EOL</code>//定义了操作系统的行尾符的常量。<br>实例<br>创建 main.js 文件，代码如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> os = <span class="built_in">require</span>(<span class="string">"os"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'endianness : '</span> + os.endianness());<span class="comment">// CPU 的字节序</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'type : '</span> + os.type());<span class="comment">// 操作系统名</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'platform : '</span> + os.platform());<span class="comment">// 操作系统名</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'total memory : '</span> + os.totalmem() + <span class="string">" bytes."</span>);<span class="comment">// 系统内存总量</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'free memory : '</span> + os.freemem() + <span class="string">" bytes."</span>);<span class="comment">// 操作系统空闲内存量</span></div></pre></td></tr></table></figure></p>
<p>代码执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">node main.js </div><div class="line">endianness : LE</div><div class="line">type : Linux</div><div class="line">platform : linux</div><div class="line">total memory : 25103400960 bytes.</div><div class="line">free memory : 20676710400 bytes.</div></pre></td></tr></table></figure></p>
<h4 id="Node-js-Path-模块"><a href="#Node-js-Path-模块" class="headerlink" title="Node.js Path 模块"></a>Node.js Path 模块</h4><p>Node.js path 模块提供了一些用于处理文件路径的小工具，我们可以通过以下方式引入该模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div></pre></td></tr></table></figure></p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>1  <code>path.normalize(p)</code>//规范化路径，注意’..’ 和 ‘.’。<br>2  <code>path.join([path1][, path2][, ...])</code>//用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是”/“，Windows系统是”\”。<br>3  <code>path.resolve([from ...], to)</code>//将 to 参数解析为绝对路径。<br>4  <code>path.isAbsolute(path)</code>//判断参数 path 是否是绝对路径。<br>5  <code>path.relative(from, to)</code>//用于将相对路径转为绝对路径。<br>6  <code>path.dirname(p)</code>//返回路径中代表文件夹的部分，同 Unix 的dirname 命令类似。<br>7  <code>path.basename(p[, ext])</code>//返回路径中的最后一部分。同 Unix 命令 bashname 类似。<br>8  <code>path.extname(p)</code>//返回路径中文件的后缀名，即路径中最后一个’.’之后的部分。如果一个路径中并不包含’.’或该路径只包含一个’.’ 且这个’.’为路径的第一个字符，则此命令返回空字符串。<br>9  <code>path.parse(pathString)</code>//返回路径字符串的对象。<br>10  <code>path.format(pathObject)</code>//从对象中返回路径字符串，和 path.parse 相反。</p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>1  <code>path.sep</code>//平台的文件路径分隔符，’\‘ 或 ‘/‘。<br>2  <code>path.delimiter</code>//平台的分隔符, ; or ‘:’.<br>3  <code>path.posix</code>//提供上述 path 的方法，不过总是以 posix 兼容的方式交互。<br>4  <code>path.win32</code>//提供上述 path 的方法，不过总是以 win32 兼容的方式交互。</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>创建 main.js 文件，代码如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"><span class="comment">// 格式化路径</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'normalization : '</span> + path.normalize(<span class="string">'/test/test1//2slashes/1slash/tab/..'</span>));</div><div class="line"><span class="comment">// 连接路径</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'joint path : '</span> + path.join(<span class="string">'/test'</span>, <span class="string">'test1'</span>, <span class="string">'2slashes/1slash'</span>, <span class="string">'tab'</span>, <span class="string">'..'</span>));</div><div class="line"><span class="comment">// 转换为绝对路径</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'resolve : '</span> + path.resolve(<span class="string">'main.js'</span>));</div><div class="line"><span class="comment">// 路径中文件的后缀名</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'ext name : '</span> + path.extname(<span class="string">'main.js'</span>));</div></pre></td></tr></table></figure></p>
<p>代码执行结果如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">node main.js </div><div class="line">normalization : <span class="regexp">/test/</span>test1/<span class="number">2</span>slashes/<span class="number">1</span>slash</div><div class="line">joint path : <span class="regexp">/test/</span>test1/<span class="number">2</span>slashes/<span class="number">1</span>slash</div><div class="line">resolve : <span class="regexp">/web/</span>com/<span class="number">1427176256</span>_27423/main.js</div><div class="line">ext name : .js</div></pre></td></tr></table></figure></p>
<h4 id="Node-js-Net-模块"><a href="#Node-js-Net-模块" class="headerlink" title="Node.js Net 模块"></a>Node.js Net 模块</h4><p>Node.js Net 模块提供了一些用于底层的网络通信的小工具，包含了创建服务器/客户端的方法，我们可以通过以下方式引入该模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">"net"</span>)</div></pre></td></tr></table></figure></p>
<h5 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h5><p>1  <code>net.createServer([options][, connectionListener])</code>//创建一个 TCP 服务器。参数 connectionListener 自动给 ‘connection’ 事件创建监听器。<br>2  <code>net.connect(options[, connectionListener])</code>//返回一个新的 ‘net.Socket’，并连接到指定的地址和端口。当 socket 建立的时候，将会触发 ‘connect’ 事件。<br>3  <code>net.createConnection(options[, connectionListener])</code>//创建一个到端口 port 和 主机 host的 TCP 连接。 host 默认为 ‘localhost’。<br>4  <code>net.connect(port[, host][, connectListener])</code>//创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 ‘localhost’。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。<br>5  <code>net.createConnection(port[, host][, connectListener])</code>//创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 ‘localhost’。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。<br>6  <code>net.connect(path[, connectListener])</code>//创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件上。返回 ‘net.Socket’。<br>7  <code>net.createConnection(path[, connectListener])</code>//创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。<br>8  <code>net.isIP(input)</code>//检测输入的是否为 IP 地址。 IPV4 返回 4， IPV6 返回 6，其他情况返回 0。<br>9  <code>net.isIPv4(input)</code>//如果输入的地址为 IPV4， 返回 true，否则返回 false。<br>10  <code>net.isIPv6(input)</code>//如果输入的地址为 IPV6， 返回 true，否则返回 false。</p>
<h4 id="net-Server"><a href="#net-Server" class="headerlink" title="net.Server"></a>net.Server</h4><p>net.Server通常用于创建一个 TCP 或本地服务器。</p>
<h5 id="net-Server方法："><a href="#net-Server方法：" class="headerlink" title="net.Server方法："></a>net.Server方法：</h5><p>1  <code>server.listen(port[, host][, backlog][, callback])</code>//监听指定端口 port 和 主机 host ac连接。 默认情况下 host 接受任何 IPv4 地址(INADDR_ANY)的直接连接。端口 port 为 0 时，则会分配一个随机端口。<br>2  <code>server.listen(path[, callback])</code>//通过指定 path 的连接，启动一个本地 socket 服务器。<br>3  <code>server.listen(handle[, callback])</code>//通过指定句柄连接。<br>4  <code>server.listen(options[, callback])</code>//options 的属性：端口 port, 主机 host, 和 backlog, 以及可选参数 callback 函数, 他们在一起调用server.listen(port, [host], [backlog], [callback])。还有，参数 path 可以用来指定 UNIX socket。<br>5  <code>server.close([callback])</code>//服务器停止接收新的连接，保持现有连接。这是异步函数，当所有连接结束的时候服务器会关闭，并会触发 ‘close’ 事件。<br>6  <code>server.address()</code>//操作系统返回绑定的地址，协议族名和服务器端口。<br>7  <code>server.unref()</code>//如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。<br>8  <code>server.ref()</code>//与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。<br>9  <code>server.getConnections(callback)</code>//异步获取服务器当前活跃连接的数量。当 socket 发送给子进程后才有效；回调函数有 2 个参数 err 和 count。</p>
<h5 id="net-Server事件："><a href="#net-Server事件：" class="headerlink" title="net.Server事件："></a>net.Server事件：</h5><p>1  <code>listening</code>//当服务器调用 server.listen 绑定后会触发。<br>2  <code>connection</code>//当新连接创建后会被触发。socket 是 net.Socket实例。<br>3  <code>close</code>//服务器关闭时会触发。注意，如果存在连接，这个事件不会被触发直到所有的连接关闭。<br>4  <code>error</code>//发生错误时触发。’close’ 事件将被下列事件直接调用。</p>
<h4 id="net-Socket"><a href="#net-Socket" class="headerlink" title="net.Socket"></a>net.Socket</h4><p>net.Socket 对象是 TCP 或 UNIX Socket 的抽象。net.Socket 实例实现了一个双工流接口。 他们可以在用户创建客户端(使用 connect())时使用, 或者由 Node 创建它们，并通过 connection 服务器事件传递给用户。</p>
<h5 id="net-Socket事件："><a href="#net-Socket事件：" class="headerlink" title="net.Socket事件："></a>net.Socket事件：</h5><p>1  <code>lookup</code>//在解析域名后，但在连接前，触发这个事件。对 UNIX sokcet 不适用。<br>2  <code>connect</code>//成功建立 socket 连接时触发。<br>3  <code>data</code>//当接收到数据时触发。<br>4  <code>end</code>//当 socket 另一端发送 FIN 包时，触发该事件。<br>5  <code>timeout</code>//当 socket 空闲超时时触发，仅是表明 socket 已经空闲。用户必须手动关闭连接。<br>6  <code>drain</code>//当写缓存为空得时候触发。可用来控制上传。<br>7  <code>error</code>//错误发生时触发。<br>8  <code>close</code>//当 socket 完全关闭时触发。参数 had_error 是布尔值，它表示是否因为传输错误导致 socket 关闭。</p>
<h5 id="net-Socket属性："><a href="#net-Socket属性：" class="headerlink" title="net.Socket属性："></a>net.Socket属性：</h5><p>1  <code>socket.bufferSize</code>//该属性显示了要写入缓冲区的字节数。<br>2  <code>socket.remoteAddress</code>//远程的 IP 地址字符串，例如：’74.125.127.100’ or ‘2001:4860:a005::68’。<br>3  <code>socket.remoteFamily</code>//远程IP协议族字符串，比如 ‘IPv4’ or ‘IPv6’。<br>4  <code>socket.remotePort</code>//远程端口，数字表示，例如：80 or 21。<br>5  <code>socket.localAddress</code>//网络连接绑定的本地接口 远程客户端正在连接的本地 IP 地址，字符串表示。例如，如果你在监听’0.0.0.0’而客户端连接在’192.168.1.1’，这个值就会是 ‘192.168.1.1’。<br>6  <code>socket.localPort</code>//本地端口地址，数字表示。例如：80 or 21。<br>7  <code>socket.bytesRead</code>//接收到得字节数。<br>8  <code>socket.bytesWritten</code>//发送的字节数。</p>
<h5 id="net-Socket方法："><a href="#net-Socket方法：" class="headerlink" title="net.Socket方法："></a>net.Socket方法：</h5><p>1  <code>new net.Socket([options])</code>//构造一个新的 socket 对象。<br>2  <code>socket.connect(port[, host][, connectListener])</code>//指定端口 port 和 主机 host，创建 socket 连接 。参数 host 默认为 localhost。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。<br>3  <code>socket.connect(path[, connectListener])</code>//打开指定路径的 unix socket。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。<br>4  <code>socket.setEncoding([encoding])</code>//设置编码<br>5  <code>socket.write(data[, encoding][, callback])</code>//在 socket 上发送数据。第二个参数指定了字符串的编码，默认是 UTF8 编码。<br>6  <code>socket.end([data][, encoding])</code>//半关闭 socket。例如，它发送一个 FIN 包。可能服务器仍在发送数据。<br>7  <code>socket.destroy()</code>//确保没有 I/O 活动在这个套接字上。只有在错误发生情况下才需要。（处理错误等等）。<br>8  <code>socket.pause()</code>//暂停读取数据。就是说，不会再触发 data 事件。对于控制上传非常有用。<br>9  <code>socket.resume()</code>//调用 pause() 后想恢复读取数据。<br>10  <code>socket.setTimeout(timeout[, callback])</code>//socket 闲置时间超过 timeout 毫秒后 ，将 socket 设置为超时。<br>11  <code>socket.setNoDelay([noDelay])</code>//禁用纳格（Nagle）算法。默认情况下 TCP 连接使用纳格算法，在发送前他们会缓冲数据。将 noDelay 设置为 true 将会在调用 socket.write() 时立即发送数据。noDelay 默认值为 true。<br>12  <code>socket.setKeepAlive([enable][, initialDelay])</code>//禁用/启用长连接功能，并在发送第一个在闲置 socket 上的长连接 probe 之前，可选地设定初始延时。默认为 false。 设定 initialDelay （毫秒），来设定收到的最后一个数据包和第一个长连接probe之间的延时。将 initialDelay 设为0，将会保留默认（或者之前）的值。默认值为0.<br>13  <code>socket.address()</code>//操作系统返回绑定的地址，协议族名和服务器端口。返回的对象有 3 个属性，比如{ port: 12346, family: ‘IPv4’, address: ‘127.0.0.1’ }。<br>14  <code>socket.unref()</code>//如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。如果服务器已被 unref，则再次调用 unref 并不会产生影响。<br>15  <code>socket.ref()</code>//与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。</p>
<h6 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h6><p>创建 server.js 文件，代码如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">connection</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'client connected'</span>);</div><div class="line">  connection.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'客户端关闭连接'</span>);</div><div class="line">  &#125;);</div><div class="line">  connection.write(<span class="string">'Hello World!\r\n'</span>);</div><div class="line">  connection.pipe(connection);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8080</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'server is listening'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>执行以上服务端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">node server.js</div><div class="line">server is listening # 服务已创建并监听8080端口</div></pre></td></tr></table></figure></p>
<p>新开一个窗口，创建client.js文件，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"><span class="keyword">var</span> client = net.connect(&#123;<span class="attr">port</span>: <span class="number">8080</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'连接服务器！'</span>);</div><div class="line">&#125;);</div><div class="line">client.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data.toString());</div><div class="line">  client.end();</div><div class="line">&#125;);</div><div class="line">client.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'断开与服务器的连接'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>执行以上客户端的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">连接服务器！</div><div class="line">Hello World!</div><div class="line">断开与服务器的连接</div></pre></td></tr></table></figure></p>
<h4 id="Node-js-DNS-模块"><a href="#Node-js-DNS-模块" class="headerlink" title="Node.js DNS 模块"></a>Node.js DNS 模块</h4><p>Node.js DNS 模块用于解析域名。引入 DNS 模块语法格式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dns = <span class="built_in">require</span>(<span class="string">"dns"</span>)</div></pre></td></tr></table></figure></p>
<h5 id="方法：-2"><a href="#方法：-2" class="headerlink" title="方法："></a>方法：</h5><p>1  <code>dns.lookup(hostname[, options], callback)</code>//将域名（比如 ‘runoob.com’）解析为第一条找到的记录 A （IPV4）或 AAAA(IPV6)。参数 options可以是一个对象或整数。如果没有提供 options，IP v4 和 v6 地址都可以。如果 options 是整数，则必须是 4 或 6。<br>2  <code>dns.lookupService(address, port, callback)</code>//使用 getnameinfo 解析传入的地址和端口为域名和服务。<br>3  <code>dns.resolve(hostname[, rrtype], callback)</code>//将一个域名（如 ‘runoob.com’）解析为一个 rrtype 指定记录类型的数组。<br>4  <code>dns.resolve4(hostname, callback)</code>//和 dns.resolve() 类似, 仅能查询 IPv4 (A 记录）。 addresses IPv4 地址数组 (比如，[‘74.125.79.104’, ‘74.125.79.105’, ‘74.125.79.106’]）。<br>5  <code>dns.resolve6(hostname, callback)</code>//和 dns.resolve4() 类似， 仅能查询 IPv6( AAAA 查询）<br>6  <code>dns.resolveMx(hostname, callback)</code>//和 dns.resolve() 类似, 仅能查询邮件交换(MX 记录)。<br>7  <code>dns.resolveTxt(hostname, callback)</code>//和 dns.resolve() 类似, 仅能进行文本查询 (TXT 记录）。 addresses 是 2-d 文本记录数组。(比如，[ [‘v=spf1 ip4:0.0.0.0 ‘, ‘~all’ ] ]）。 每个子数组包含一条记录的 TXT 块。根据使用情况可以连接在一起，也可单独使用。<br>8  <code>dns.resolveSrv(hostname, callback)</code>//和 dns.resolve() 类似, 仅能进行服务记录查询 (SRV 记录）。 addresses 是 hostname可用的 SRV 记录数组。 SRV 记录属性有优先级（priority），权重（weight）, 端口（port）, 和名字（name） (比如，[{‘priority’: 10, ‘weight’: 5, ‘port’: 21223, ‘name’: ‘service.example.com’}, …]）。<br>9  <code>dns.resolveSoa(hostname, callback)</code>//和 dns.resolve() 类似, 仅能查询权威记录(SOA 记录）。<br>10  <code>dns.resolveNs(hostname, callback)</code>//和 dns.resolve() 类似, 仅能进行域名服务器记录查询(NS 记录）。 addresses 是域名服务器记录数组（hostname 可以使用） (比如, [‘ns1.example.com’, ‘ns2.example.com’]）。<br>11  <code>dns.resolveCname(hostname, callback)</code>//和 dns.resolve() 类似, 仅能进行别名记录查询 (CNAME记录)。addresses 是对 hostname 可用的别名记录数组 (比如，, [‘bar.example.com’]）。<br>12  <code>dns.reverse(ip, callback)</code>//反向解析 IP 地址，指向该 IP 地址的域名数组。<br>13  <code>dns.getServers()</code>//返回一个用于当前解析的 IP 地址数组的字符串。<br>14  <code>dns.setServers(servers)</code>//指定一组 IP 地址作为解析服务器。</p>
<h5 id="rrtypes"><a href="#rrtypes" class="headerlink" title="rrtypes"></a>rrtypes</h5><p>dns.resolve()方法中有效的rrtypes值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&apos;A&apos; IPV4 地址, 默认</div><div class="line">&apos;AAAA&apos; IPV6 地址</div><div class="line">&apos;MX&apos; 邮件交换记录</div><div class="line">&apos;TXT&apos; text 记录</div><div class="line">&apos;SRV&apos; SRV 记录</div><div class="line">&apos;PTR&apos; 用来反向 IP 查找</div><div class="line">&apos;NS&apos; 域名服务器记录</div><div class="line">&apos;CNAME&apos; 别名记录</div><div class="line">&apos;SOA&apos; 授权记录的初始值</div></pre></td></tr></table></figure></p>
<h5 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h5><p>每次 DNS 查询都可能返回以下错误码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">dns.NODATA: 无数据响应。</div><div class="line">dns.FORMERR: 查询格式错误。</div><div class="line">dns.SERVFAIL: 常规失败。</div><div class="line">dns.NOTFOUND: 没有找到域名。</div><div class="line">dns.NOTIMP: 未实现请求的操作。</div><div class="line">dns.REFUSED: 拒绝查询。</div><div class="line">dns.BADQUERY: 查询格式错误。</div><div class="line">dns.BADNAME: 域名格式错误。</div><div class="line">dns.BADFAMILY: 地址协议不支持。</div><div class="line">dns.BADRESP: 回复格式错误。</div><div class="line">dns.CONNREFUSED: 无法连接到 DNS 服务器。</div><div class="line">dns.TIMEOUT: 连接 DNS 服务器超时。</div><div class="line">dns.EOF: 文件末端。</div><div class="line">dns.FILE: 读文件错误。</div><div class="line">dns.NOMEM: 内存溢出。</div><div class="line">dns.DESTRUCTION: 通道被摧毁。</div><div class="line">dns.BADSTR: 字符串格式错误。</div><div class="line">dns.BADFLAGS: 非法标识符。</div><div class="line">dns.NONAME: 所给主机不是数字。</div><div class="line">dns.BADHINTS: 非法HINTS标识符。</div><div class="line">dns.NOTINITIALIZED: c c-ares 库尚未初始化。</div><div class="line">dns.LOADIPHLPAPI: 加载 iphlpapi.dll 出错。</div><div class="line">dns.ADDRGETNETWORKPARAMS: 无法找到 GetNetworkParams 函数。</div><div class="line">dns.CANCELLED: 取消 DNS 查询。</div></pre></td></tr></table></figure></p>
<h6 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h6><p>创建 main.js 文件，代码如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dns = <span class="built_in">require</span>(<span class="string">'dns'</span>);</div><div class="line">dns.lookup(<span class="string">'www.github.com'</span>,<span class="function"><span class="keyword">function</span> <span class="title">onLookup</span>(<span class="params">err, address, family</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'ip 地址：'</span>, address);</div><div class="line">  dns.reverse(address, <span class="function"><span class="keyword">function</span>(<span class="params">err, hostname</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">      <span class="built_in">console</span>.log(err.stack);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'反向解析'</span> + address + <span class="string">':'</span> + <span class="built_in">JSON</span>.stringify(hostname));</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>执行以上代码，结果如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">address: 192.30.252.130</div><div class="line">reverse for 192.30.252.130: [&quot;github.com&quot;]</div></pre></td></tr></table></figure></p>
<h4 id="Node-js-Domain-模块"><a href="#Node-js-Domain-模块" class="headerlink" title="Node.js Domain 模块"></a>Node.js Domain 模块</h4><p>Node.js Domain(域) 简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的异常。引入 Domain 模块 语法格式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> domain = <span class="built_in">require</span>(<span class="string">"domain"</span>)</div></pre></td></tr></table></figure></p>
<p>domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即推出，与process.on(‘uncaughtException’)不同。<br>Domain 模块可分为隐式绑定和显式绑定：<br>1、隐式绑定: 把在domain上下文中定义的变量，自动绑定到domain对象<br>2、显式绑定: 把不是在domain上下文中定义的变量，以代码的方式绑定到domain对象</p>
<h5 id="方法：-3"><a href="#方法：-3" class="headerlink" title="方法："></a>方法：</h5><p>1  <code>domain.run(function)</code>//在域的上下文运行提供的函数，隐式的绑定了所有的事件分发器，计时器和底层请求。<br>2  <code>domain.add(emitter)</code>//显式的增加事件<br>3  <code>domain.remove(emitter)</code>//删除事件。<br>4  <code>domain.bind(callback)</code>//返回的函数是一个对于所提供的回调函数的包装函数。当调用这个返回的函数被时，所有被抛出的错误都会被导向到这个域的 error 事件。<br>5  <code>domain.intercept(callback)</code>//和 domain.bind(callback) 类似。除了捕捉被抛出的错误外，它还会拦截 Error 对象作为参数传递到这个函数。<br>6  <code>domain.enter()</code>//进入一个异步调用的上下文，绑定到domain。<br>7  <code>domain.exit()</code>//退出当前的domain，切换到不同的链的异步调用的上下文中。对应domain.enter()。<br>8  <code>domain.dispose()</code>//释放一个domain对象，让node进程回收这部分资源。<br>9  <code>domain.create()</code>//返回一个domain对象。</p>
<h5 id="事件："><a href="#事件：" class="headerlink" title="事件："></a>事件：</h5><p>1  <code>domain.menbers</code>//已加入domain对象的域定时器和事件发射器的数组。</p>
<h6 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h6><p>创建 main.js 文件，代码如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">"events"</span>).EventEmitter;</div><div class="line"><span class="keyword">var</span> domain = <span class="built_in">require</span>(<span class="string">"domain"</span>);</div><div class="line"><span class="keyword">var</span> emitter1 = <span class="keyword">new</span> EventEmitter();</div><div class="line"><span class="comment">// 创建域</span></div><div class="line"><span class="keyword">var</span> domain1 = domain.create();</div><div class="line">domain1.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">"domain1 处理这个错误 ("</span>+err.message+<span class="string">")"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 显式绑定</span></div><div class="line">domain1.add(emitter1);</div><div class="line">emitter1.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">"监听器处理此错误 ("</span>+err.message+<span class="string">")"</span>);</div><div class="line">&#125;);</div><div class="line">emitter1.emit(<span class="string">'error'</span>,<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'通过监听器来处理'</span>));</div><div class="line">emitter1.removeAllListeners(<span class="string">'error'</span>);</div><div class="line">emitter1.emit(<span class="string">'error'</span>,<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'通过 domain1 处理'</span>));</div><div class="line"><span class="keyword">var</span> domain2 = domain.create();</div><div class="line">domain2.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">"domain2 处理这个错误 ("</span>+err.message+<span class="string">")"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 隐式绑定</span></div><div class="line">domain2.run(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   <span class="keyword">var</span> emitter2 = <span class="keyword">new</span> EventEmitter();</div><div class="line">   emitter2.emit(<span class="string">'error'</span>,<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'通过 domain2 处理'</span>));   </div><div class="line">&#125;);</div><div class="line">domain1.remove(emitter1);</div><div class="line">emitter1.emit(<span class="string">'error'</span>, <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'转换为异常，系统将崩溃!'</span>));</div></pre></td></tr></table></figure></p>
<p>执行以上代码，结果如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">监听器处理此错误 (通过监听器来处理)</div><div class="line">domain1 处理这个错误 (通过 domain1 处理)</div><div class="line">domain2 处理这个错误 (通过 domain2 处理)</div><div class="line">events.js:72</div><div class="line">        throw er; // Unhandled &apos;error&apos; event</div><div class="line">              ^</div><div class="line">Error: 转换为异常，系统将崩溃!</div><div class="line">    at Object.&lt;anonymous&gt; (/www/node/main.js:40:24)</div><div class="line">    at Module._compile (module.js:456:26)</div><div class="line">    at Object.Module._extensions..js (module.js:474:10)</div><div class="line">    at Module.load (module.js:356:32)</div><div class="line">    at Function.Module._load (module.js:312:12)</div><div class="line">    at Function.Module.runMain (module.js:497:10)</div><div class="line">    at startup (node.js:119:16)</div><div class="line">    at node.js:929:3</div></pre></td></tr></table></figure></p>
</div><div class="tags"><a href="/tags/node/">node</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2016/06/29/Node.js JXcore打包.html" class="pre">Node.js JXcore 打包(18)</a><a href="/2016/06/29/Node.js GET POST请求.html" class="next">Node.js GET/POST请求(12)</a></div><div id="comments"><div data-thread-key="2016/06/29/Node.js 工具模块.html" data-title="Node.js 工具模块(13)" data-url="https://wpneu.github.io/2016/06/29/Node.js 工具模块.html" data-author-key="1" class="ds-thread"></div><div id="uyan_frame"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#13、Node-js-工具模块"><span class="toc-text">13、Node.js 工具模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-js-OS-模块"><span class="toc-text">Node.js OS 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#方法："><span class="toc-text">方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#属性："><span class="toc-text">属性：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-js-Path-模块"><span class="toc-text">Node.js Path 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#方法"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#属性"><span class="toc-text">属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#实例"><span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-js-Net-模块"><span class="toc-text">Node.js Net 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#方法：-1"><span class="toc-text">方法：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#net-Server"><span class="toc-text">net.Server</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#net-Server方法："><span class="toc-text">net.Server方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#net-Server事件："><span class="toc-text">net.Server事件：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#net-Socket"><span class="toc-text">net.Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#net-Socket事件："><span class="toc-text">net.Socket事件：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#net-Socket属性："><span class="toc-text">net.Socket属性：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#net-Socket方法："><span class="toc-text">net.Socket方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#实例-1"><span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-js-DNS-模块"><span class="toc-text">Node.js DNS 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#方法：-2"><span class="toc-text">方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rrtypes"><span class="toc-text">rrtypes</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#错误码"><span class="toc-text">错误码</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#实例-2"><span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-js-Domain-模块"><span class="toc-text">Node.js Domain 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#方法：-3"><span class="toc-text">方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#事件："><span class="toc-text">事件：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#实例-3"><span class="toc-text">实例</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/12/29/BlueLake博客主题的详细配置.html">BlueLake博客主题的详细配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/09/自定义HEXO站内搜索Javascript-json.html">自定义HEXO站内搜索Javascript+json</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/17/github博客迁移.html">github博客迁移</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/12/Web包管理器-Bower.html">好用的Web包管理器-Bower</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/30/MongoDB学习笔记(2).html">MongoDB学习笔记(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/29/MongoDB学习笔记(1).html">MongoDB学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/30/Node.js 多进程.html">Node.js 多进程(17)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/30/Node.js RESTful API.html">Node.js RESTful API(16)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/30/Node.js Express 框架.html">Node.js Express 框架(15)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/Node.js Web模块.html">Node.js Web 模块(14)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/hexo博客折腾/">hexo博客折腾</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodeJS学习笔记/">nodeJS学习笔记</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端工具/">前端工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言集成查询/">语言集成查询</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/BlueLake/" style="font-size: 15px;">BlueLake</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/linq/" style="font-size: 15px;">linq</a> <a href="/tags/语言集成查询/" style="font-size: 15px;">语言集成查询</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/sublime/" style="font-size: 15px;">sublime</a> <a href="/tags/bower/" style="font-size: 15px;">bower</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">王志平(Gavin.Wang).</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cadefac847f0a4087a8bfc06bff3bbf2";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>var duoshuoQuery = {short_name:'http://wpneu.oschina.io/'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    document.getElementsByTagName('body')[0].appendChild(ds);
})();
</script><script src="http://v2.uyan.cc/code/uyan.js?uid=2140301"></script></body></html>